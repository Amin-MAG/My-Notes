# Design

We have system design and program design. In system design, we define our components and their relations to each other. In program design, We discuss the design patterns that can be used in writing codes. (function, classes, and...)

Designing needs knowledge and creativity. 

The key to good design is simplicity and simplicity itself comes from creativity. We should seek simplicity in our design because the best designs are easy to understand, implement, test, and maintain.

The environment can affect our design. For example, using a framework might enforce the developer to implement specific design and architecture. Other examples are databases or testing frameworks. 

So it is kind of important to consider the testing framework that we are going to use. Because it may affect our design.

Most of our decisions in the design and architectural level is emanated from these 2 principles.

1. Coupling (to decrease coupling)

    The components should have less relation and connectivity with each other as much as possible. The components are actually our features so they are kind of separate.  

2. Cohesion (to increase cohesion)

    The classes in a component should be highly connected and related to each other.

It is important to check these principles when you're designing. 

One way of representing our design is UML and there are many other ideas about this representation. Actually, It depends on the situation and maybe using another representation for our design is better that UML form.

# Component

A component is a replaceable part of a system that conforms to and provides the realization of a 
set of interfaces. It actually a subsystem. It is a distributable piece of implementation of a system.

We are able to make UML definition of a component.

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled.png)

Each component has 2 ports that represent the import and export APIs. The import port represents every APIs that pass in data to this component, And the export port actually represents all of the APIs that have been exposed from that component and we can use them.

Note: Each component talks to outside world just by their interfaces.

Set of component can be in a package. Also, Each one of the components may live on nodes.

# Architectural Styles

## Monolithic

Like kernel.

Note: In microservices anything that is not microservice is monolithic and it is different from this concept of being monolithic.

## Pipe

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%201.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%201.png)

- It is used in compiler.
- Low-Coupling

    Note: Because of this it can have many variations like compilers.

- End-To-End testing is easy.
- It is not good for a parallel scenario.
- Error propagation issue.

## Client-Server (Centralized)

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%202.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%202.png)

Benefits:

- Low-Coupling
- Easy testing
- Security
    - Talking about insider attack. (Chain Attack)
- Simple

Disadvantages

- Scale-out
- Single point of failure
- Cost

Note: Each one of server or client can have its own design and architecture.

### Security

It is CIA.

- C for Confidentiality: Can not read our messages.
- I for Integrity: Can not change our files.
- A for Availability: Being available.

### Encryption

The best encryptions are AES and after that DES. Social media are using DES because the security on the other hand is to break the encryption to control the activities.

### Handle lots of request

Buffering and make a queue could be a solutions but it doesn't work usually. 

Another ways are:

- Scale-up is to improve the hardware.
- Scale-out is to add new servers.

## P2P (Distributed)

Each node could be client or server.

Benefits:

- They are distributed so that is is not single point of failure.

Disadvantages

- Black holes

### Ad Hoc

### MOM

### RTA

## SEMI-P2P

We add some servers to resolve some issues in P2P. But cause single point of failure in a way.

## Repository (Black board)

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%203.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%203.png)

Git or DBMS use this architecture style. The actions on repository are atomic. Other example could be Wikipedia that is a knowledge base site and people can read and write.

Disadvantages:

- Single point of failure
- It is a little complex.
- Repository has high-Coupling (Solutions would be using an Interface above the Repository component, DAO, or Separating write & read)

Benefits:

- Flexible for Data-Intensive systems.

### Repository with storage access layer

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%204.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%204.png)

The data store subsystem can be changed without modifying any component except the Storage access.

## MVC (Model-View-Controller)

- Controller contains logic things.
- Model contains data and entities.
- View

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%205.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%205.png)

Here we can have one-to-n relation between these layers.

MVC vs 3-layer-architecture

- Unlike a 3-layer architecture, the first layer that receives the request is the controller. After that, the controller will return the view.
- MVC has two kinds of variations, passive or active. When it is passive model should be updated by the controller, but on the other hand, it can update itself without controller involvement.
- MVC has less coupling.
- Performance and scaling is  easier in MVC. (because of the relations between layers)

This is the famous MVC one. Coupling is important to us so if we want to keep it without dependency, we should use a kind of notifier like an observer. (dash line)

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%206.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%206.png)

## MVP (Model-View-Presenter)

It is a variation of MVC. There is no relation between view and model.

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%207.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%207.png)

In MVP each view only interacts with one presenter. Actually here is a one-to-one relation.

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%208.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%208.png)

In android applications

## MVVM

In MVVM the relation between view and view model is on directional unlike the MVP.

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%209.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%209.png)

## MVT (Django)

# Time-Critical Systems

They're systems that their functionalities depend on their result and the time they have been produced.

Types of Time-Critical Systems

- Hard:
    - Auto pilot
    - Atomic systems
- Soft
    - Games

Note: Real time means that you have a limitation on your response time.

## Daemon

![Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%2010.png](Design%207dfad2ecbc7d48b9a985b7992566034d/Untitled%2010.png)

There is a daemon that dispatches the incoming request to processes, or it can create a new process to respond to that request.

## Distributed Data Systems

The systems that work with plenty of data.

- Mirror (Same system just like each other)
    - It decrease the database over head.
    - Make it more reliable.
    - Better performance because of less response time. (Geographical example about google)

    Note: Mirrors just look act like system but can not change or update things.

- Cache (Save the responses for the most incoming requests)
    - Better performance because of less response time.

### CAP Theory

It says you can not have these three together.

- Consistency
- Availability
- Partition

## Buffering

## Three Tier Architecture

Tier is physical but layer is logical.

Advantages

- Simple
- Testing Upper and lower layer

Disadvantages

- More coupling
- Performance
- Testing middle layer

We have two kind of variation, open and close layer architecture.

## Event-Driven

Main difference between message and event is that event make a change in the system although a message necessarily doesn't.

 There are two entities in these kind of architecture.

- Emitters or sources
- Consumers

### Event Mediator

ATC Example

It make less coupling. There is no relations kind of airplanes.

## Frontend-Backend

What is the difference between this architecture and client-server?

Client-Server is essentially in separate nodes but we can have both of frontend and backend in one node. (So actually the difference is physically)

## Distributed Computing

### Shared Nothing

Map reduced