# OOD

It is going to focus on individual concepts and itâ€™s not just generally speaking.

## Definition of Great Software

System Design: Maintainability, Flexibility, Extendability, Low Complexity

Non-Functional: Security, Performance & Efficiency, User Friendly

The definition of great software depends on the context of the software. Letâ€™s see what do different programmers say about the Great Software.

The customer-friendly programmer

> The system do the things that the customer needs. (User Requirements, Not Buggy)
> 

The object-oriented programmer

> The system has Object-Oriented design and we follow the principles in that system. (DRY, Extendable design, Single Responsibility)
> 

The design-guru programmer

> Your objects in the system are loosely coupled and the system is open for extension but closed for modification.
> 

We have different stages to define the â€œGreat Softwareâ€, The essential part of being a Great Software is to be `customer-friendly` and do what is expecting to do. (For the projects that are not starting from scratch) If we rich this part and want to have a better and Great Software, we need to follow `object-oriented` designs to make our code more extendable and better for future usage. At the last step, we need to consider the coupling for our system. (`design-guru`)

The main answer or approach:

1. Make sure the software does what the customer wants
2. Apply good object-oriented principles
3. Strive for a maintainable, reusable design

## Maintainability

- It has a readable code base, So another developer can read and understand it.
- Itâ€™s easy to fix the bugs in the project
- The system can work and continue properly.

## Encapsulation

- Hides the details
- Hides complexity
- Has some interface to interact with it (public methods)

Components use the API to interact and communicate with this component, So any changes in this component shouldnâ€™t break the others (If the APIs are designed perfectly).

We kinda limit the interaction between components.

## DRY

Against of Copy-Paste programming. Donâ€™t Repeat Yourself!

- Itâ€™s difficult to apply changes to the code
- Makes terrible bugs
- Makes our code less readable (Itâ€™s ugly)

## Information Expert

We have some classes and some methods, The Information Expert says â€œPut the methods in the classes which has the key and basic information for that method.â€

## Regression testing

Your changes should be tested. The refactoring should comes with testing.

# Requirements

How to provide our software requirements, Stakeholders are the ones.

- Customers
- End User
- Development Team Members
- Management
- Technology providers

## Design for Dog remote

![Untitled](OOD%2093469a64e6e243b3a47c49df5394721a/Untitled.png)

## Use cases

Use case describes all ways to achieve the goal from a specific starting point. It could be formal or informal.

Three part of a use case

- Clear Value: Every use case has a clear value to the system. It helps the users to achieve their goal.
- Start and Stop: Describe the start and stop state clearly and precisely.
- External Initiators

The constant thing in softwares is change ðŸ™‚

# Software in Real World

Asking `What if` Question helps us to find different scenarios.

## Analysis

- Studying the nature of something, determining its essential features and their relations.
- Exhibiting complex concepts or propositions
- Evaluation of an activity

## Delegation

Delegation is to pass parameter and give the duty by passing objects to another class.

Delegation shields your objects from implementation changes to other objects in your software.

## Use case

`Requirement Analysis`

It Addresses complete goal-oriented sequences of actions the system must perform. Use cases if for requirement analysis. 

Explicitly describes multiple paths in our system. It can used for user story estimation.

## CRC

`Technical`

Class-Responsibility-Collaborator is a kind of diagram that is different from class diagrams.

- Itâ€™s good to show the single responsibilities. (To recognize God-classes and blob classes)
- Itâ€™s a good diagram to show the dependencies between the classes.
- It helps us to make sure that we consider all of the scenarios.

![Untitled](OOD%2093469a64e6e243b3a47c49df5394721a/Untitled%201.png)

The CRC cares about the requirements, but The class diagram shows the code structure.

Implicitly represents multiple path and scenarios.

## User Stories

`Technical`

On contrast of use cases, We can talk about the technical aspect of system. It describes a single feature or unit of work for a developer. The user stories should be designed in a way that is testable. (It means that it shouldnâ€™t be vague) 

The user stories shouldnâ€™t get too long. 

Itâ€™s good for individual task estimation.

## Use Case, CRC, User Story

![Untitled](OOD%2093469a64e6e243b3a47c49df5394721a/Untitled%202.png)

## Epic VS stories agile development

![Untitled](OOD%2093469a64e6e243b3a47c49df5394721a/Untitled%203.png)

### Initiative

Each project includes some different parts that a separate team is going to work on it. Each one of these parts are an Initiative of our project.

### Epic

Each Initiative has some Epics. Epics are the feature of that Initiative that should be done.

> Epic is use case here
> 

### Story

The Epics consist of some Stories or Tasks that developer is going to estimate and complete it. (Developer add some subtasks to the tasks) 

## Opposing

Another vision is to have Theme instead of Initiator.

![Untitled](OOD%2093469a64e6e243b3a47c49df5394721a/Untitled%204.png)

There are no wrong and correct point of view it depends on your context and your project

![Untitled](OOD%2093469a64e6e243b3a47c49df5394721a/Untitled%205.png)

This is another point of view for a large scale project.

## Extract Classes

- Textual analysis: Look at the nouns in requirements
- Entities and concepts: From application domain
- Experience

# Design

- Designs have a purpose.
- Designs have enough informations so that someone can implement it.
- There are different styles of designs.

It is the process of planning how to solve a problem through software. Itâ€™s a blueprint for developer. 

It should be easy to understand, flexible, satisfies the requirements, and...

By asking `What If` question, we can understand that how much our design is good.

## Use properties field

Some time the child classes donâ€™t have any different behavior from their parents and the only thing is their fields. When you have different fields for a type you can make a `properties` field that is a Map data structure and put the attributes there. Having separate child classes is not needed here.

> Class are about behavior. If the class doesnâ€™t have any behavior there is no need for class.
> 

# Other pages

[The Final Exam](OOD%2093469a64e6e243b3a47c49df5394721a/The%20Final%20Exam%2040ff877ac94b4fdda929476bed0df85c.md)